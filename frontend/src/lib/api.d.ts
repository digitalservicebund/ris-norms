/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/verkuendungen": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a list of all verkuendungen */
    get: {
      parameters: {
        query?: never
        header?: never
        path?: never
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of verkuendungen */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Verkuendung"][]
          }
        }
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    /** Create a new verkuendung by uploading the XML of a norm */
    post: {
      parameters: {
        query?: {
          /** @description If norm already exists, override it */
          force?: boolean
        }
        header?: never
        path?: never
        cookie?: never
      }
      requestBody: {
        content: {
          "multipart/form-data": {
            /** Format: binary */
            file?: string
          }
        }
      }
      responses: {
        /** @description Norm was successfully created */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Norm"]
          }
        }
        422: components["responses"]["ValidationError"]
        500: components["responses"]["InternalServerError"]
      }
    }
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/verkuendungen/{expressionEli}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a specific verkuendung by its expression ELI */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description Requested verkuendung */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Verkuendung"]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/verkuendungen/{expressionEli}/zielnormen": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get the list of created expressions of zielnormen of a specific Verkuendung */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of Zielnormen */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Norm"][]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/verkuendungen/{expressionEli}/zielnormen/expressions/preview": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get the list of zielnorm expressions that should be set to gegenstandslos or be created when applying all the currently existing ZielnormReferences of the Verkündung */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["NormExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of Zielnormen Preview Informations */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Zielnormen"][]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/verkuendungen/{expressionEli}/zielnormen/{zielWorkEli}/expressions/create": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /** Create new expressions by applying all the currently existing Zielnorm references to the Verkündung */
    post: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["NormExpressionEli"]
          zielWorkEli: components["schemas"]["NormWorkEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of Zielnormen with all changed expressions */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Zielnormen"]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a list of all norm works */
    get: {
      parameters: {
        query?: {
          /** @description The page of the results */
          page?: number
          /** @description The size of the pages */
          size?: number
        }
        header?: never
        path?: never
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of works. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": {
              content?: components["schemas"]["NormWork"][]
              page?: {
                size?: number
                number?: number
                totalElements?: number
                totalPages?: number
              }
            }
          }
        }
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{workEli}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get information about the work level norm */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          workEli: components["schemas"]["NormWorkEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description Information about the norm. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["NormWork"]
          }
        }
        /** @description Norm not found. */
        404: {
          headers: {
            [name: string]: unknown
          }
          content?: never
        }
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{workEli}/expressions": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get basic information about all the expressions of the work */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          workEli: components["schemas"]["NormWorkEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of expressions of the target norm. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": {
              eli?: components["schemas"]["NormExpressionEli"]
              gegenstandslos?: boolean
            }[]
          }
        }
        /** @description Norm not found. */
        404: {
          headers: {
            [name: string]: unknown
          }
          content?: never
        }
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{workEli}/releases": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get status of expressions that are unpublished */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          workEli: components["schemas"]["NormWorkEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of expression status for the target norm. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ExpressionsStatusResponseSchema"]
          }
        }
        /** @description Norm not found. */
        404: {
          headers: {
            [name: string]: unknown
          }
          content?: never
        }
      }
    }
    put?: never
    /** Publish expressions of this norm */
    post: {
      parameters: {
        query?: never
        header?: never
        path: {
          workEli: components["schemas"]["NormWorkEli"]
        }
        cookie?: never
      }
      requestBody: {
        content: {
          "application/json": components["schemas"]["ReleaseRequest"]
        }
      }
      responses: {
        /** @description List of expression status for the target norm. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ExpressionsStatusResponseSchema"]
          }
        }
        /** @description Norm not found. */
        404: {
          headers: {
            [name: string]: unknown
          }
          content?: never
        }
      }
    }
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/eli/bund/{agent}/{year}/{naturalIdentifier}/{pointInTime}/{version}/{language}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a specific norm by its expression ELI */
    get: {
      parameters: {
        query?: {
          /** @description Should the metadata table be included? (only for Content-Type: text/html) */
          showMetadata?: boolean
        }
        header?: never
        path: {
          /** @description Expression ELI of the norm */
          agent: string
          /** @description Expression ELI of the norm */
          year: string
          /** @description Expression ELI of the norm */
          naturalIdentifier: string
          /** @description Expression ELI of the norm */
          pointInTime: string
          /** @description Expression ELI of the norm */
          version: number
          /** @description Expression ELI of the norm */
          language: string
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description Expression of the requested norm */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Norm"]
            "application/xml": components["schemas"]["LegalDocML.de"]
            "text/html": string
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    /** Update a specific norm by its expression ELI */
    put: {
      parameters: {
        query?: never
        header?: never
        path: {
          /** @description Expression ELI of the norm */
          expressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      /** @description The XML of the norm (which may be updated and saved on DB) */
      requestBody: {
        content: {
          "application/xml": components["schemas"]["LegalDocML.de"]
        }
      }
      responses: {
        /** @description Updated expression of the norm */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/xml": components["schemas"]["LegalDocML.de"]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{expressionEli}/elements/{eid}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a single element inside a norm */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
          /** @description eId of the element inside the norm */
          eid: components["schemas"]["EId"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description The element inside the norm */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ElementResponse"]
            "text/html": string
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{expressionEli}/articles": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a list of articles for a specific norm by its expression ELI */
    get: {
      parameters: {
        query?: {
          /** @description Filter by the article's `refersTo` literal (`refersToLiterals.einzelvorschrift` in the specification). Only for `Content-Type: text/html` */
          refersTo?: string
        }
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description The list of articles in the requested norm */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Article"][]
            "text/html": string
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{expressionEli}/articles/{eid}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a specific article by eId for a given norm */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
          /** @description eId of the article */
          eid: components["schemas"]["EId"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description The article with the requested eId */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["Article"]
            "text/html": string
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{expressionEli}/zeitgrenzen": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get all time boundaries for a given norm */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of time boundaries */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ZeitgrenzeResponse"][]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    /** Update all time boundaries for a given norm */
    put: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      /** @description List of new time boundaries of a norm */
      requestBody: {
        content: {
          "application/json": components["schemas"]["ZeitgrenzeRequest"][]
        }
      }
      responses: {
        /** @description Updated time boundaries */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ZeitgrenzeResponse"][]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{normExpressionEli}/zielnorm-references": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a list of zielnorm references */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          normExpressionEli: components["schemas"]["NormExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description The list of zielnorm references */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ZielnormReference"][]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    /** Update or add zielnorm references */
    post: {
      parameters: {
        query?: never
        header?: never
        path: {
          normExpressionEli: components["schemas"]["NormExpressionEli"]
        }
        cookie?: never
      }
      /** @description The zielnorm references that should be updated or added. If a reference for the given eId already exists it is updated. If it does not exist yet it is created. All other references remain unchanged. */
      requestBody?: {
        content: {
          "application/json": components["schemas"]["ZielnormReference"][]
        }
      }
      responses: {
        /** @description List of all zielnorm references, including the update */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ZielnormReference"][]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    /** Delete zielnorm references */
    delete: {
      parameters: {
        query?: never
        header?: never
        path: {
          normExpressionEli: components["schemas"]["NormExpressionEli"]
        }
        cookie?: never
      }
      /** @description The eIds for which the zielnorm references that should be deleted. */
      requestBody?: {
        content: {
          "application/json": components["schemas"]["EId"][]
        }
      }
      responses: {
        /** @description List of all (remaining) zielnorm references */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["ZielnormReference"][]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{dokumentExpressionEli}/proprietary": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get the proprietary metadata of Dokument */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          dokumentExpressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of proprietary metadata */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["SingleElementMetadata"]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    /** Replace the proprietary metadata of a Dokument */
    put: {
      parameters: {
        query?: never
        header?: never
        path: {
          dokumentExpressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      /** @description The proprietary request schema containing several metadata. */
      requestBody: {
        content: {
          "application/json": components["schemas"]["SingleElementMetadata"]
        }
      }
      responses: {
        /** @description Metadata was updated successfully. Returns the updated metadata. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["SingleElementMetadata"]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{dokumentExpressionEli}/proprietary/{eid}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get the proprietary metadata of a single element */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          dokumentExpressionEli: components["schemas"]["DokumentExpressionEli"]
          /** @description The eId of the selected single element */
          eid: components["schemas"]["EId"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description List of proprietary metadata for the single element */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["SingleElementMetadata"]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    /** Replace the proprietary metadata of a single element */
    put: {
      parameters: {
        query?: never
        header?: never
        path: {
          dokumentExpressionEli: components["schemas"]["DokumentExpressionEli"]
          /** @description The eId of the selected single element */
          eid: components["schemas"]["EId"]
        }
        cookie?: never
      }
      /** @description The proprietary request schema containing several metadata. */
      requestBody: {
        content: {
          "application/json": components["schemas"]["SingleElementMetadata"]
        }
      }
      responses: {
        /** @description Metadata for a single element was updated successfully. Returns the updated metadata. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["SingleElementMetadata"]
          }
        }
        400: components["responses"]["BadRequest"]
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{expressionEli}/{eid}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get an element of a norm by its eId (currently only in HTML preview format) */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          expressionEli: components["schemas"]["DokumentExpressionEli"]
          /** @description eId of the element in the norm */
          eid: components["schemas"]["EId"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description An HTML rendering of the element */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "text/html": string
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{manifestationEli}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Get a specific norm by its manifestation ELI */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          /** @description Manifestation ELI of the norm. Currently only `xml` is supported as the format. */
          manifestationEli: components["schemas"]["DokumentManifestationEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description The requested norm. The response format depends on the format as specified in the manifestation ELI. */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/xml": components["schemas"]["LegalDocML.de"]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/renderings": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /** Create and return an HTML rendering of the provided LDML.de XML */
    post: {
      parameters: {
        query?: {
          /** @description Should the metadata table be included? */
          showMetadata?: boolean
        }
        header?: never
        path?: never
        cookie?: never
      }
      requestBody: {
        content: {
          "application/xml": string
        }
      }
      responses: {
        /** @description HTML rendering the provided LDML.de XML */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "text/html": string
          }
        }
        400: components["responses"]["BadRequest"]
        500: components["responses"]["InternalServerError"]
      }
    }
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/environment": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Return configuration for the frontend specific to the current environment */
    get: {
      parameters: {
        query?: never
        header?: never
        path?: never
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description Configuration for the frontend specific to the current environment */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": {
              name?: string
              authClientId?: string
              authRealm?: string
              authUrl?: string
            }
          }
        }
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/norms/{dokumentExpressionEli}/toc": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Retrieve the table of contents of a Regelungstext */
    get: {
      parameters: {
        query?: never
        header?: never
        path: {
          dokumentExpressionEli: components["schemas"]["DokumentExpressionEli"]
        }
        cookie?: never
      }
      requestBody?: never
      responses: {
        /** @description Table of contents successfully retrieved */
        200: {
          headers: {
            [name: string]: unknown
          }
          content: {
            "application/json": components["schemas"]["TableOfContentsResponse"][]
          }
        }
        404: components["responses"]["NotFound"]
        500: components["responses"]["InternalServerError"]
      }
    }
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
}
export type webhooks = Record<string, never>
export interface components {
  schemas: {
    /**
     * Format: DokumentExpressionEli
     * @description ELI identifying a specific Dokument of a specific expression of a norm
     * @example eli/bund/bgbl-1/2021/s4/2021-03-01/1/deu/regelungstext-verkuendung-1
     */
    DokumentExpressionEli: string
    /**
     * Format: DokumentManifestationEli
     * @description ELI identifying a specific Dokument of a specific manifestation of a norm
     * @example eli/bund/bgbl-1/2021/s4/2021-03-01/1/deu/2024-02-01/regelungstext-verkuendung-1.xml
     */
    DokumentManifestationEli: string
    /**
     * Format: NormExpressionEli
     * @description ELI identifying a specific expression of a norm
     * @example eli/bund/bgbl-1/2021/s4/2021-03-01/1/deu
     */
    NormExpressionEli: string
    /**
     * Format: NormWorkEli
     * @description ELI identifying a specific norm (the whole work)
     * @example eli/bund/bgbl-1/2021/s4
     */
    NormWorkEli: string
    /**
     * Format: EId
     * @description eId, identifying an element of a norm
     * @example hauptteil-1_art-3
     */
    EId: string
    Norm: {
      eli?: components["schemas"]["DokumentExpressionEli"]
      title?: string
      shortTitle?: string
      fna?: string
      frbrName?: string
      frbrNumber?: string
      /** Format: date */
      frbrDateVerkuendung?: string
      status?: string
      vorherigeVersionId?: string
      nachfolgendeVersionId?: string
    }
    NormWork: {
      eli?: components["schemas"]["NormWorkEli"]
      title?: string
    }
    Verkuendung: {
      eli?: components["schemas"]["DokumentExpressionEli"]
      title?: string
      shortTitle?: string
      fna?: string
      frbrName?: string
      frbrNumber?: string
      /** Format: date */
      frbrDateVerkuendung?: string
      /** Format: date */
      dateAusfertigung?: string
      /** Format: date */
      importedAt?: string
    }
    Article: {
      eid?: components["schemas"]["EId"]
      enumeration?: string
      title?: string
    }
    ZeitgrenzeRequest: {
      /** Format: date */
      date?: string
      /** @enum {string} */
      art?: "INKRAFT" | "AUSSERKRAFT"
    }
    ZeitgrenzeResponse: {
      id?: string
      /** Format: date */
      date?: string
      /** @enum {string} */
      art?: "INKRAFT" | "AUSSERKRAFT"
    }
    ZielnormReference: {
      typ?: string
      geltungszeit?: string
      eId?: components["schemas"]["EId"]
      zielnorm?: components["schemas"]["NormExpressionEli"]
      isNewWork?: boolean
    }
    /** @description Summarizing the newly created expressions for a Zielnorm after applying a Verkuendung */
    Zielnormen: {
      normWorkEli?: components["schemas"]["NormWorkEli"]
      title?: string
      shortTitle?: string
      expressions?: {
        normExpressionEli?: components["schemas"]["NormExpressionEli"]
        /** @description Is the expression gegenstandslos? */
        isGegenstandslos?: boolean
        /** @description Does this expression already exist in the system? */
        isCreated?: boolean
        /** @description Would this expression be deleted if the Verkuendung is applied? */
        isOrphan?: boolean
        /**
         * @description Explanation for the reason that this expression will be set to gegenstandslos or be created
         *      * "andere Verkündung" - An existing expression, created by a different Verkündung, that will be set to gegenstandslos
         *      * "diese Verkündung" - It's created due to a ZielnormReference that uses this date
         *      * "System" - It's created automatically by the system. Usually when replacing a now gegenstandslose expression
         *
         * @enum {string}
         */
        createdBy?: "diese Verkündung" | "andere Verkündung" | "System"
      }[]
    }
    ReleaseResponse: {
      /** Format: date-time */
      releaseAt?: string
      norms?: components["schemas"]["DokumentManifestationEli"][]
    }
    "LegalDocML.de": Record<string, never>
    ElementResponse: {
      eli?: string
      title?: string
      /** @enum {string} */
      type?:
        | "preface"
        | "preamble"
        | "article"
        | "conclusions"
        | "book"
        | "chapter"
        | "part"
        | "section"
        | "subsection"
        | "title"
        | "subtitle"
    }
    Metadata: {
      /** @description FNA (Fundstellennachweis A) of the norm */
      fna?: string
      /** @description Art ("Art der Norm") of the norm */
      art?: string
      /** @description Type ("Typ") of the document */
      typ?: string
      /** @description Subtype ("Subtyp") of the document */
      subtyp?: string
      /** @description Designation according to specification ("Bezeichnung gemäß Vorlage") of the document */
      bezeichnungInVorlage?: string
      /** @description SN,ÄN,ÜN ("Art der Norm") of the norm */
      artDerNorm?: string
      /** @description DEU,DDR,BW... ("Staat, Land, Stadt, Landkreis oder juristische Person, deren Hoheitsgewalt oder Rechtsmacht die Norm trägt") of the norm */
      staat?: string
      /** @description ("Beschließendes Organ") of the norm */
      beschliessendesOrgan?: string
      /** @description Boolean value if beschliessendesOrgan had a ("Qualifizierte Mehrheit") when deciding */
      qualifizierteMehrheit?: boolean
      /** @description ("Organisationseinheit") of the norm */
      organisationsEinheit?: string
    }
    SingleElementMetadata: {
      /** @description SN or ÄN or ÜN ("Art der Norm") of the single element */
      artDerNorm?: string
    }
    ProblemDetail: {
      /**
       * Format: uri
       * @description A URI reference that identifies the problem type.
       * @example /errors/norm-not-found
       */
      type: string
      /**
       * @description A short, human-readable summary of the problem type.
       * @example Norm not found
       */
      title?: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 404
       */
      status?: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example Norm with eli this-is-not-an-eli does not exist
       */
      detail?: string
      /**
       * Format: uri
       * @description The api call URI that triggered the exception.
       * @example /api/v1/norms/this-is-not-an-eli
       */
      instance?: string
    } & {
      [key: string]: unknown
    }
    TableOfContentsResponse: {
      /**
       * Format: EId
       * @description The eId of the XML node
       * @example hauptteil-1_art-3
       */
      id?: string
      /** @description The marker of the item (e.g. § 1) */
      marker?: string
      /** @description The heading of the item, if present. If the article contains an eingebundene Stammform, this will be the long title of the Stammform. */
      heading?: string
      /** @description The type of the item (e.g. section or chapter) */
      type?: string
      eingebundeneStammformEli?: components["schemas"]["DokumentManifestationEli"] &
        unknown &
        unknown
      /** @description Nested children elements of the table of contents */
      children?: components["schemas"]["TableOfContentsResponse"][]
    }
    ExpressionsStatusResponseSchema: {
      normWorkEli?: components["schemas"]["NormWorkEli"]
      /** @description The title of the zielnorm. */
      title?: string
      /** @description Short title of the zielnorm. */
      shortTitle?: string
      expressions?: components["schemas"]["Expression"][]
    }
    Expression: {
      normExpressionEli?: components["schemas"]["NormExpressionEli"]
      /** @description Set to true if the expression will become gegenstandslos. */
      isGegenstandslos?: boolean
      currentStatus?: components["schemas"]["Status"]
    }
    /**
     * @description Release status of the expression.
     * @enum {string}
     */
    Status: "NOT_RELEASED" | "PRAETEXT_RELEASED" | "VOLLDOKUMENTATION_RELEASED"
    ReleaseRequest: {
      /** @enum {string} */
      releaseType: "praetext" | "volldokumentation"
    }
  }
  responses: {
    /** @description One or more resource(s) not found */
    NotFound: {
      headers: {
        [name: string]: unknown
      }
      content: {
        "application/problem+json": components["schemas"]["ProblemDetail"]
      }
    }
    /** @description Internal server error */
    InternalServerError: {
      headers: {
        [name: string]: unknown
      }
      content: {
        "application/problem+json": components["schemas"]["ProblemDetail"]
      }
    }
    /** @description Malformed request (e.g. required parameters are missing or in the wrong format) */
    BadRequest: {
      headers: {
        [name: string]: unknown
      }
      content: {
        "application/problem+json": components["schemas"]["ProblemDetail"]
      }
    }
    /** @description Input data is invalid */
    ValidationError: {
      headers: {
        [name: string]: unknown
      }
      content: {
        "application/problem+json": components["schemas"]["ProblemDetail"]
      }
    }
  }
  parameters: never
  requestBodies: never
  headers: never
  pathItems: never
}
export type $defs = Record<string, never>
export type operations = Record<string, never>
